import { GameRecap } from '@/types/league';
import { getScheduleGames } from './schedule-data-supabase';
import { getAllScores, getScoreForGame } from './scores-data-supabase';
import { getAllRecaps as getSupabaseRecaps, getRecapByGameId as getSupabaseRecapByGameId, upsertRecap, deleteRecap as deleteSupabaseRecap } from './supabase-data';

/**
 * Get recaps data from Supabase
 */
export async function getRecapsFromStorage(): Promise<GameRecap[]> {
  const recaps = await getSupabaseRecaps();
  return recaps.map(recap => ({
    id: recap.id || 0,
    gameId: parseInt(recap.game_id) || 0,
    date: recap.date,
    time: recap.time,
    team1: recap.team1,
    team2: recap.team2,
    score1: recap.score1,
    score2: recap.score2,
    location: recap.location,
    highlights: recap.highlights || [],
    playerOfTheMatch: recap.player_of_the_match || '',
    attendance: recap.attendance || 0,
    weather: recap.weather || '',
    recap: recap.recap,
    photos: recap.photos || [],
  }));
}

/**
 * Save a recap to Supabase
 */
export async function saveRecapToStorage(recap: GameRecap): Promise<{ success: boolean; error?: string }> {
  const supabaseRecap = {
    game_id: recap.gameId.toString(),
    date: recap.date,
    time: recap.time,
    team1: recap.team1,
    team2: recap.team2,
    score1: recap.score1,
    score2: recap.score2,
    location: recap.location,
    highlights: recap.highlights,
    player_of_the_match: recap.playerOfTheMatch,
    attendance: recap.attendance,
    weather: recap.weather,
    recap: recap.recap,
    photos: recap.photos,
  };
  
  return await upsertRecap(supabaseRecap);
}

/**
 * Delete a recap from Supabase
 */
export async function deleteRecapFromStorage(gameId: number): Promise<{ success: boolean; error?: string }> {
  return await deleteSupabaseRecap(gameId.toString());
}

/**
 * Get all games with scores that can have recaps generated
 */
export async function getGamesWithScores() {
  const scheduleGames = await getScheduleGames();
  const allScores = await getAllScores();
  
  // Create a map of gameIDs to scores for quick lookup
  const scoresMap = new Map(allScores.map(score => [score.gameID, score]));
  
  // Filter games that have scores
  const gamesWithScores = scheduleGames
    .filter(game => game.gameID && scoresMap.has(game.gameID))
    .map(game => {
      const score = scoresMap.get(game.gameID!)!;
      return {
        ...game,
        score1: score.score1,
        score2: score.score2,
      };
    });
  
  return gamesWithScores;
}

/**
 * Generate a basic recap for a game
 */
export async function generateBasicRecap(gameId: number, customData?: Partial<GameRecap>): Promise<GameRecap | null> {
  const scheduleGames = await getScheduleGames();
  const game = scheduleGames.find(g => g.id === gameId);
  
  if (!game || !game.gameID) return null;
  
  const score = await getScoreForGame(game.gameID);
  if (!score) return null;
  
  // Generate default highlights
  const winner = score.score1 > score.score2 ? score.team1 : score.team2;
  const loser = score.score1 > score.score2 ? score.team2 : score.team1;
  const winnerScore = Math.max(score.score1, score.score2);
  const loserScore = Math.min(score.score1, score.score2);
  const margin = winnerScore - loserScore;
  
  const defaultHighlights = [
    `Final score: ${score.team1} ${score.score1} - ${score.score2} ${score.team2}`,
    margin <= 5 
      ? `Close game! ${winner} edges out ${loser} by ${margin} points`
      : `Dominant performance by ${winner} with a ${margin} point victory`,
    `Great competitive game at the Mana League`
  ];
  
  const recap: GameRecap = {
    id: gameId,
    gameId: gameId,
    date: game.date,
    time: game.time,
    team1: game.team1,
    team2: game.team2,
    score1: score.score1,
    score2: score.score2,
    location: game.location,
    highlights: customData?.highlights || defaultHighlights,
    playerOfTheMatch: customData?.playerOfTheMatch || `MVP from ${winner}`,
    attendance: customData?.attendance || 45,
    weather: customData?.weather || 'Clear, 72Â°F',
    recap: customData?.recap,
    photos: customData?.photos || [],
    stats: customData?.stats,
  };
  
  return recap;
}

/**
 * Get all recaps (stored + auto-generated from scores)
 */
export async function getAllRecaps(): Promise<GameRecap[]> {
  const storedRecaps = await getRecapsFromStorage();
  const gamesWithScores = await getGamesWithScores();
  
  // Create a map of gameIds that have stored recaps
  const storedRecapIds = new Set(storedRecaps.map(r => r.gameId));
  
  // Generate basic recaps for games that have scores but no stored recap
  const autoGeneratedRecapsPromises = gamesWithScores
    .filter(game => !storedRecapIds.has(game.id))
    .map(game => generateBasicRecap(game.id));
  
  const autoGeneratedRecaps = (await Promise.all(autoGeneratedRecapsPromises))
    .filter((recap): recap is GameRecap => recap !== null);
  
  // Combine stored recaps with auto-generated ones
  return [...storedRecaps, ...autoGeneratedRecaps]
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

/**
 * Get a specific recap by gameId
 */
export async function getRecapByGameId(gameId: number): Promise<GameRecap | null> {
  const storedRecaps = await getRecapsFromStorage();
  const storedRecap = storedRecaps.find(r => r.gameId === gameId);
  
  if (storedRecap) return storedRecap;
  
  // Try to generate a basic recap
  return generateBasicRecap(gameId);
}

/**
 * Clear all recaps (no-op for Supabase)
 */
export function clearRecapsFromStorage() {
  console.warn('clearRecapsFromStorage is not implemented for Supabase');
}

